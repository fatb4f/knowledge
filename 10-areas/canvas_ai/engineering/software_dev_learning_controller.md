# Software-Dev Learning Controller

## Canonical Definition

**This learning system is a model-based adaptive control loop governing all software development learning activities.**

It treats learning as a stateful, observable, constraint-driven system rather than a curriculum.

---

## Core Foundations (Non-Negotiable)

### Pillar 1 — Computation as a System
- Codebases, tools, and workflows are state machines
- Interfaces, invariants, and transitions are explicit
- Learning artifacts preserve system state

### Pillar 2 — Statistics as Inference
- Understanding is probabilistic, not binary
- Hypotheses are explicit and falsifiable
- Errors and confusion are signals, not failures

### Pillar 3 — Control & Adaptation
- Learning pace and depth are parameters
- Drift and overload trigger control updates
- Stability has priority over speed

---

## Complementing Methodologies (Controller Ergonomics)

These do **not** replace the pillars. They operationalize them.

### Systems Engineering (Lightweight)
- State → Transition → Invariant
- Interface before implementation
- Evidence over belief

### Scientific Method (Operational)
1. Hypothesis
2. Intervention
3. Measurement
4. Model update or discard

### Observability (Human-Scale)
- Leading indicators: fatigue, friction, latency to clarity
- Lagging indicators: error rate, rework
- Signals must be cheap to observe

### Constraint-Driven Design
- Constraints named first
- Optimization occurs *within* constraints
- Constraints expand only with evidence

### Model-Based Thinking
- Cheap, explicit mental models
- Wrong-but-useful approximations
- Models are disposable

---

## Control Loop (Abstract)

1. Define constraints
2. Propose model
3. Execute task
4. Observe signals
5. Update parameters or model
6. Preserve state

---

## Failure Modes This System Prevents

- Overengineering
- Toolchain sprawl
- Burnout-driven resets
- False mastery
- Context loss after interruption

---

## Standing Directive

**All Python and Rust learning tracks must conform to this controller.**

Curricula, tools, and exercises are treated as inputs.
Progress is measured by stability and retained capability, not velocity.
